package main

import (
	"bufio"
	"fmt"
	"os"
	"strconv"
	"strings"
)

var reader = bufio.NewReader(os.Stdin)

func readInt() int {
	n := 0
	fmt.Fscanf(reader, "%d\n", &n)
	return n
}

func readInt64() int64 {
	n := int64(0)
	fmt.Fscanf(reader, "%d\n", &n)
	return n
}

func readString() string {
	s, _ := reader.ReadString('\n')
	return strings.TrimSpace(s)
}

func readSliceInt() []int {
	s := strings.TrimSpace(readString())
	if s == "" {
		return []int{}
	}
	data := strings.Split(s, " ")
	res := make([]int, len(data))
	for i, v := range data {
		res[i], _ = strconv.Atoi(v)
	}
	return res
}

func readSliceInt64() []int64 {
	s := strings.TrimSpace(readString())
	if s == "" {
		return []int64{}
	}
	data := strings.Split(s, " ")
	res := make([]int64, len(data))
	for i, v := range data {
		res[i], _ = strconv.ParseInt(v, 10, 64)
	}
	return res
}

func readSliceString() []string {
	s := strings.TrimSpace(readString())
	if s == "" {
		return []string{}
	}
	return strings.Split(s, " ")
}

func printSlice[T any](l []T) {
	output := make([]string, len(l))
	for i, v := range l {
		output[i] = fmt.Sprint(v)
	}
	fmt.Println(strings.Join(output, " "))
}

func Max[T int | float32 | string | int64 | byte](args ...T) T {
	res := args[0]
	for i := 1; i < len(args); i++ {
		if args[i] > res {
			res = args[i]
		}
	}
	return res
}

func Min[T int | float32 | string | int64 | byte](args ...T) T {
	res := args[0]
	for i := 1; i < len(args); i++ {
		if args[i] < res {
			res = args[i]
		}
	}
	return res
}

func Sum[T int | float32 | int64](args ...T) T {
	var res T
	for _, v := range args {
		res += v
	}
	return res
}

func abs[T int | int64](v T) T {
	if v < 0 {
		return -v
	}
	return v
}

func reverseStr(s string) string {
	rns := []rune(s) // convert to rune
	for i, j := 0, len(rns)-1; i < j; i, j = i+1, j-1 {
		// swap the letters of the string,
		// like first with last and so on.
		rns[i], rns[j] = rns[j], rns[i]
	}

	// return the reversed string.
	return string(rns)
}

func Unique[T comparable](l []T) []T {
	m := map[T]bool{}
	for _, v := range l {
		m[v] = true
	}
	res := make([]T, 0, len(l))
	for v := range m {
		res = append(res, v)
	}
	return res
}

func divceil[T int | int64](a, b T) T {
	res := a / b
	if a%b > 0 {
		res += 1
	}
	return res
}

func makeRange(i, j int) []int {
	res := make([]int, j-i)
	for k := 0; k < len(res); k++ {
		res[k] = i + k
	}
	return res
}

func Repeat[T any](v T, n int) []T {
	res := make([]T, n)
	for i := 0; i < n; i++ {
		res[i] = v
	}
	return res
}

func divneg[T int | int64](a, b T) T {
	res := a / b
	m := a % b
	if m < 0 {
		res -= 1
	}
	return res
}

func accumulate(a []int64) []int64 {
	res := make([]int64, len(a)+1)
	for i, v := range a {
		res[i+1] = res[i] + v
	}
	return res
}

func Count[T comparable](l []T) map[T]int {
	m := map[T]int{}
	for _, v := range l {
		m[v] += 1
	}
	return m
}

func Keys[K comparable, V any](m map[K]V) []K {
	res := []K{}
	for k := range m {
		res = append(res, k)
	}
	return res
}

const MOD = 998244353

// const MOD = 1000000007
const maxn = 1000000

// var FAC = make([]int64, maxn+1)
// var IFAC = make([]int64, maxn+1)

// func init() {
// 	FAC[0], FAC[1] = 1, 1
// 	IFAC[0], IFAC[1] = 1, 1
// 	for i := int64(2); i < maxn+1; i++ {
// 		FAC[i] = (i * FAC[i-1]) % MOD
// 		IFAC[i] = mod_inverse(FAC[i])
// 	}
// }

func pow(x, n int64) int64 {
	x = x % MOD
	res := int64(1)
	for n > 0 {
		if n%2 == 1 {
			res = (res * x) % MOD
		}
		x = (x * x) % MOD
		n = n / 2
	}
	return res
}

func mod_inverse(x int64) int64 {
	return pow(x, MOD-2)
}

// func comb(n, k int64) int64 {
// 	if n < 0 || k > n {
// 		return 0
// 	}
// 	inv := (IFAC[k] * IFAC[n-k]) % MOD
// 	return (FAC[n] * inv) % MOD
// }

func mod[T int | int64](v T) T {
	res := v % MOD
	if res < 0 {
		res += MOD
	}
	return res
}

func reverse[T any](l []T) {
	i, j := 0, len(l)-1
	for i < j {
		l[i], l[j] = l[j], l[i]
		i, j = i+1, j-1
	}
}

// https://codeforces.com/contest/1969/problem/D
// choose k items => all other items with a[i]<b[i] and b[i]<=min(b among k) is taken
// => sort b by descending; create a heap to store k items with min a => maxheap to pop a with max value

type Heap []int64

func (h Heap) Len() int           { return len(h) }
func (h Heap) Less(i, j int) bool { return h[i] > h[j] }
func (h Heap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }

func (h *Heap) Push(x any) {
	// Push and Pop use pointer receivers because they modify the slice's length,
	// not just its contents.
	*h = append(*h, x.(int64))
}

func (h *Heap) Pop() any {
	old := *h
	n := len(old)
	x := old[n-1]
	*h = old[0 : n-1]
	return x
}

type UnionFind []int

func (u UnionFind) Find(x int) int {
	if u[x] != x {
		u[x] = u.Find(u[x])
	}
	return u[x]
}

func (u UnionFind) Union(x, y int) {
	u[u.Find(y)] = u.Find(x)
}

func (u UnionFind) NGroup() int {
	res := 0
	for i, v := range u {
		if i == v {
			res++
		}
	}
	return res
}

func ListRemove[T comparable](l []T, v T) []T {
	for i, x := range l {
		if x == v {
			l[i], l[len(l)-1] = l[len(l)-1], l[i]
			return l[:len(l)-1]
		}
	}
	return l

}

type Stack[T any] struct {
	data []T
	i    int
}

func (s *Stack[T]) Top() T {
	return s.data[s.i-1]
}

func (s *Stack[T]) Len() int {
	return s.i
}

func (s *Stack[T]) Push(v T) {
	if s.i == len(s.data) {
		s.data = append(s.data, v)
	} else {
		s.data[s.i] = v
	}
	s.i += 1
}

func (s *Stack[T]) Pop() T {
	s.i -= 1
	if s.i < 0 {
		panic("Invalid stack pop: stack is empty")
	}
	return s.data[s.i]
}

func (s *Stack[T]) ToList() []T {
	return s.data[:s.i]
}

func NewStack[T any]() *Stack[T] {
	return &Stack[T]{data: []T{}, i: 0}
}

func TarjanInt(graph [][]int) []int {
	n := len(graph)
	lowLinks := Repeat(-1, n)
	onstack := make([]bool, n)
	stack := NewStack[int]()

	globalid := 1

	var strongconnect func(int)
	strongconnect = func(v int) {
		if lowLinks[v] >= 0 {
			return
		}
		index := globalid
		globalid += 1

		// index := len(lowLinks)
		lowLinks[v] = index
		stack.Push(v)
		onstack[v] = true
		for _, w := range graph[v] {
			strongconnect(w)
			if onstack[w] {
				lowLinks[v] = Min(lowLinks[v], lowLinks[w])
			}
		}
		if lowLinks[v] == index {
			for {
				w := stack.Pop()
				onstack[w] = false
				if w == v {
					break
				}
			}
		}
	}
	for v := 0; v < n; v++ {
		strongconnect(v)
	}

	return lowLinks
}

func GetDAGFromSCSInt(graph [][]int, sccs []int) map[int][]int {
	n := len(graph)
	marked, connected := make([]bool, n), map[[2]int]bool{}
	var dp func(int)
	dp = func(i int) {
		if marked[i] {
			return
		}
		marked[i] = true
		for _, j := range graph[i] {
			key := [2]int{sccs[i], sccs[j]}
			if key[0] != key[1] {
				connected[key] = true
			}

			dp(j)
		}
	}
	for i := 0; i < n; i++ {
		dp(i)
	}
	res := map[int][]int{}
	for pair := range connected {
		res[pair[0]] = append(res[pair[0]], pair[1])
	}
	return res
}

func run(a []int, roads [][]int) int {
	n := len(a)
	graph := make([][]int, n)
	for _, r := range roads {
		i, j := r[0]-1, r[1]-1
		graph[i] = append(graph[i], j)
	}
	tar := TarjanInt(graph)
	dag := GetDAGFromSCSInt(graph, tar)
	count := map[int]int{}
	for i, v := range a {
		count[tar[i]] += v
	}
	marked := map[int]bool{}

}

func main() {
	ntest := readInt()
	// ntest := 1
	for nt := 0; nt < ntest; nt++ {
		l := readSliceInt()
		a := readSliceInt()
		roads := make([][]int, l[1])
		for i := range roads {
			roads[i] = readSliceInt()
		}
		fmt.Println(run(a, roads))
	}
	// graph := [][]int{{1}, {2}, {0}, {1, 2, 4}, {3, 6}, {5, 4, 7}, {2, 7}, {6}}
	// tar := TarjanInt(graph)
	// fmt.Println(tar)
	// fmt.Println(GetDAGFromSCSInt(graph, tar))
	// fmt.Println(TarjanInt(graph))
}
